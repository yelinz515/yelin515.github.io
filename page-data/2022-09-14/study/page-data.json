{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/2022-09-14/study/",
    "result": {"data":{"cur":{"id":"5374a095-daf4-595e-b79b-162ae06193ab","html":"<h2 id=\"과제---token\" style=\"position:relative;\"><a href=\"#%EA%B3%BC%EC%A0%9C---token\" aria-label=\"과제   token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>과제 - Token</h2>\n<hr>","excerpt":"과제 - Token","frontmatter":{"date":"September 14, 2022","title":"[과제] Token","categories":"codestates blog","author":"김예린","emoji":null},"fields":{"slug":"/2022-09-14/study/"}},"next":{"id":"bc3c07ca-d605-54cc-b2eb-5cfd3bba5ee2","html":"<p>지난 시간에 Cookie, Session에 대해 알아보았습니다. 오늘은 Token에 대해 알아보도록 하겠습니다.</p>\n<h2 id=\"token\" style=\"position:relative;\"><a href=\"#token\" aria-label=\"token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Token</h2>\n<hr>\n<blockquote>\n<p>토큰은 “나는 돈을 지불했고, 이 시설 또는 서비스를 사용할 수 있어!”라는 메시지를 담고 있는 입장 티켓이라고 이해할 수 있습니다.</p>\n</blockquote>\n<p>이러한 개념에서 착안하여 클라이언트에서 인증 정보를 보관하는 방법으로 토큰기반 인증이 고안되었습니다.</p>\n<ul>\n<li>\n<p>그러면 토큰을 클라이언트에 저장하는 것이 위험하지 않나요?</p>\n<p>토큰은 유저 정보를 암호화했기 때문에, 클라이언트에 담을 수 있습니다.</p>\n</li>\n</ul>\n<h3 id=\"jwt\" style=\"position:relative;\"><a href=\"#jwt\" aria-label=\"jwt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT</h3>\n<p>JWT는 엑세스 토큰, 리프레시 토큰을 이용해 인증 구현을 합니다. 권한을 부여 받는 데엔 엑세스 토큰만 가지고 있으면 되지만, 유효기간이 만료된다면 리프레시 토큰을 사용하여 새로운 토큰을 발급받아야 합니다. 이때 유저는 다시 로그인할 필요가 없습니다.</p>\n<p><img src=\"/dbf3f3cb75b44a69a376012120d2cc2c/JWT.png\" alt=\"github-blog.png\"></p>\n<br>\n<p>JWT 구조에 대해 알아보겠습니다.</p>\n<h4 id=\"1-header\" style=\"position:relative;\"><a href=\"#1-header\" aria-label=\"1 header permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Header</h4>\n<hr>\n<p>어떤 종류의 토큰인지, 어떤 알고리즘으로 암호화 할 지 적혀있습니다.</p>\n<h4 id=\"2-payload\" style=\"position:relative;\"><a href=\"#2-payload\" aria-label=\"2 payload permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Payload</h4>\n<hr>\n<p>유저의 정보, 어떤 정보에 접근 가능한지에 대한 권한을 담을 수 있고, 기타 필요한 정보가 적혀있습니다.</p>\n<h4 id=\"3-signiture\" style=\"position:relative;\"><a href=\"#3-signiture\" aria-label=\"3 signiture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Signiture</h4>\n<hr>\n<p>Header, Payload를 base64인코딩한 값과 salt값의 조합으로 암호화된 값이 적혀있습니다.</p>\n<br>\n<p><strong>누군가 권한을 속이기 위해 Payload를 변조하여 base64로 인코딩하더라도 원본 Payload로 암호화한 시그니처 값과 다르기 때문에 서버가 해당 토큰이 변조되었음을 확인할 수 있습니다.</strong></p>","frontmatter":{"date":"September 14, 2022","title":"Token","categories":"codestates blog","author":"김예린","emoji":null},"fields":{"slug":"/2022-09-14/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://yelinz515.github.io","comments":{"utterances":{"repo":"yelinz515/blog-comments"}}}}},"pageContext":{"slug":"/2022-09-14/study/","nextSlug":"/2022-09-14/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}